// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sensor_data_query.sql

package sqlc

import (
	"context"
	"time"
)

const deleteSensorData = `-- name: DeleteSensorData :exec
DELETE FROM sensor_data
WHERE id1 = ? AND id2 = ? AND timestamp = ?
`

type DeleteSensorDataParams struct {
	Id1       string    `json:"id1"`
	Id2       int32     `json:"id2"`
	Timestamp time.Time `json:"timestamp"`
}

func (q *Queries) DeleteSensorData(ctx context.Context, arg DeleteSensorDataParams) error {
	_, err := q.db.ExecContext(ctx, deleteSensorData, arg.Id1, arg.Id2, arg.Timestamp)
	return err
}

const getSensorDataByID = `-- name: GetSensorDataByID :many
SELECT id, sensor_value, sensor_type, id1, id2, timestamp, created_at, updated_at, deleted_at FROM sensor_data
WHERE id1 = ? AND id2 = ?
`

type GetSensorDataByIDParams struct {
	Id1 string `json:"id1"`
	Id2 int32  `json:"id2"`
}

func (q *Queries) GetSensorDataByID(ctx context.Context, arg GetSensorDataByIDParams) ([]SensorDatum, error) {
	rows, err := q.db.QueryContext(ctx, getSensorDataByID, arg.Id1, arg.Id2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SensorDatum
	for rows.Next() {
		var i SensorDatum
		if err := rows.Scan(
			&i.ID,
			&i.SensorValue,
			&i.SensorType,
			&i.Id1,
			&i.Id2,
			&i.Timestamp,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSensorDataByTime = `-- name: GetSensorDataByTime :many
SELECT id, sensor_value, sensor_type, id1, id2, timestamp, created_at, updated_at, deleted_at FROM sensor_data
WHERE timestamp BETWEEN ? AND ?
`

type GetSensorDataByTimeParams struct {
	FromTimestamp time.Time `json:"from_timestamp"`
	ToTimestamp   time.Time `json:"to_timestamp"`
}

func (q *Queries) GetSensorDataByTime(ctx context.Context, arg GetSensorDataByTimeParams) ([]SensorDatum, error) {
	rows, err := q.db.QueryContext(ctx, getSensorDataByTime, arg.FromTimestamp, arg.ToTimestamp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SensorDatum
	for rows.Next() {
		var i SensorDatum
		if err := rows.Scan(
			&i.ID,
			&i.SensorValue,
			&i.SensorType,
			&i.Id1,
			&i.Id2,
			&i.Timestamp,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertSensorData = `-- name: InsertSensorData :exec
INSERT INTO sensor_data (sensor_value, sensor_type, id1, id2, timestamp)
VALUES (?, ?, ?, ?, ?)
`

type InsertSensorDataParams struct {
	SensorValue float64   `json:"sensor_value"`
	SensorType  string    `json:"sensor_type"`
	Id1         string    `json:"id1"`
	Id2         int32     `json:"id2"`
	Timestamp   time.Time `json:"timestamp"`
}

func (q *Queries) InsertSensorData(ctx context.Context, arg InsertSensorDataParams) error {
	_, err := q.db.ExecContext(ctx, insertSensorData,
		arg.SensorValue,
		arg.SensorType,
		arg.Id1,
		arg.Id2,
		arg.Timestamp,
	)
	return err
}

const updateSensorData = `-- name: UpdateSensorData :exec
UPDATE sensor_data
SET sensor_value = ?
WHERE id1 = ? AND id2 = ? AND timestamp = ?
`

type UpdateSensorDataParams struct {
	SensorValue float64   `json:"sensor_value"`
	Id1         string    `json:"id1"`
	Id2         int32     `json:"id2"`
	Timestamp   time.Time `json:"timestamp"`
}

func (q *Queries) UpdateSensorData(ctx context.Context, arg UpdateSensorDataParams) error {
	_, err := q.db.ExecContext(ctx, updateSensorData,
		arg.SensorValue,
		arg.Id1,
		arg.Id2,
		arg.Timestamp,
	)
	return err
}
